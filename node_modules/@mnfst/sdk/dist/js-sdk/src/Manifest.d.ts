import { Paginator } from "../../core/types/src";
export default class Manifest {
    /**
     * The Manifest backend base URL (Without ending slash).
     */
    baseUrl: string;
    /**
     * The slug of the entity to query.
     */
    private slug;
    /**
     * A flag to determine if the entity is a single entity or a collection.
     */
    isSingleEntity: boolean;
    /**
     * The headers of the request.
     */
    private headers;
    /**
     * The query parameters of the request.
     */
    private queryParams;
    /**
     * Create a new instance of the client.
     *
     * @param baseUrl The Manifest backend URL address (Without ending slash). Default: http://localhost:1111
     */
    constructor(baseUrl?: string);
    /**
     * Set the slug of the entity to query.
     *
     * @param slug The slug of the entity to query.
     *
     * @returns The current instance of the client.
     * @example client.from('cats').find();
     */
    from(slug: string): this;
    /**
     * Set the slug of the single entity to query.
     *
     * @param slug The slug of the single entity to query.
     *
     * @returns an object containing the methods to get and update the single entity.
     *
     * @example client.single('about').get()
     * @example client.single('home').update({ title: 'New title' })
     */
    single(slug: string): {
        get: <T>() => Promise<T>;
        update: <T>(data: unknown) => Promise<T>;
    };
    /**
     * Get the paginated list of items of the entity.
     *
     * @param paginationParams - Optional pagination parameters.
     *
     * @returns A Promise that resolves a Paginator object containing entities of type T, based on the input.
     */
    find<T>(paginationParams?: {
        page?: number;
        perPage?: number;
    }): Promise<Paginator<T>>;
    /**
     * Get an item of the entity.
     *
     * @param id The id of the item to get.
     *
     * @returns The item of the entity.
     * @example client.from('cats').findOne(1);
     *
     **/
    findOneById<T>(id: number): Promise<T>;
    /**
     * Create an item of the entity.
     *
     * @param itemDto The DTO of the item to create.
     *
     * @returns The created item.
     */
    create<T>(itemDto: unknown): Promise<T>;
    /**
     * Update an item of the entity doing a full replace. Leaving blank fields and relations will remove them. Use patch for partial updates.
     *
     * @param id The id of the item to update.
     * @param itemDto The DTO of the item to update.
     *
     * @returns The updated item.
     * @example client.from('cats').update(1, { name: 'updated name' });
     */
    update<T>(id: number, itemDto: unknown): Promise<T>;
    /**
     * Partially update an item of the entity. Leaving blank fields and relations will not remove them. Use update for full replaces.
     *
     * @param id The id of the item to update.
     * @param itemDto The DTO of the item to update.
     *
     * @returns The updated item.
     * @example client.from('cats').update(1, { name: 'updated name' });
     */
    patch<T>(id: number, itemDto: unknown): Promise<T>;
    /**
     *
     * Delete an item of the entity.
     *
     * @param id The id of the item to delete.
     *
     * @returns The id of the deleted item.
     * @example client.from('cats').delete(1);
     */
    delete(id: number): Promise<number>;
    /**
     *
     * Adds a where clause to the query.
     *
     * @param whereClause The where clause to add.
     *
     * @returns The current instance of the client.
     * @example client.from('cats').where('age = 10').find();
     */
    where(whereClause: string): this;
    /**
     * Adds a where clause to the query.
     *
     * @param whereClause
     * @returns The current instance of the client.
     * @example client.from('cats').andWhere('age = 10').find();
     */
    andWhere(whereClause: string): this;
    /**
     * Adds an order by clause to the query.
     *
     * @param propName The property name to order by.
     * @param order The order of the property (ASC or DESC). Default ASC
     *
     * @returns The current instance of the client.
     * @example client.from('cats').orderBy('age', { desc: true }).find();
     */
    orderBy(propName: string, order?: {
        desc: boolean;
    }): this;
    /**
     * Loads the relations of the entity.
     *
     * @param relations The relations to load.
     *
     * @returns The current instance of the client.
     * @example client.from('cats').with(['owner', 'owner.company']).find();
     */
    with(relations: string[]): this;
    /**
     *
     * Login as any authenticable entity.
     *
     * @param entitySlug The slug of the entity to login as.
     * @param email The email of the entity to login as.
     * @param password The password of the entity to login as.
     *
     * @returns true if the login was successful.
     */
    login(entitySlug: string, email: string, password: string): Promise<boolean>;
    /**
     *
     * Logout as any authenticable entity.
     *
     * @returns void
     */
    logout(): void;
    /**
     * Signup as any authenticable entity but Admin and login.
     *
     * @param entitySlug The slug of the entity to signup as.
     * @param email The email of the entity to signup as.
     * @param password The password of the entity to signup as.
     *
     * @returns true if the signup was successful.
     */
    signup(entitySlug: string, email: string, password: string): Promise<boolean>;
    /**
     * Gets the current logged in user (me). Use "from('your-entity')" before calling this method.
     *
     * @returns The current logged in user.
     * @example client.from('users').me();
     *
     */
    me(): Promise<{
        email: string;
    }>;
    private fetch;
    /**
     * Upload a file to the entity.
     *
     * @param property The property of the entity to upload the file to.
     * @param file The file to upload.
     *
     * @returns true if the upload was successful.
     */
    upload(property: string, file: Blob): Promise<boolean>;
    /**
     * Upload an image to the entity.
     *
     * @param property The property of the entity to upload the image to.
     * @param image The image to upload.
     *
     * @returns an object containing the path of the uploaded image in different sizes.
     * */
    uploadImage(property: string, image: Blob): Promise<{
        [key: string]: string;
    }>;
    /**
     * Helper that returns the absolute URL of the image.
     *
     * @param image The image object containing the different sizes of the image.
     *
     * @returns The absolute URL of the image.
     */
    imageUrl(image: {
        [key: string]: string;
    }, size: string): string;
}
